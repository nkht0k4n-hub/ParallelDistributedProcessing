2026/01/29 並列分散処理


並列分散処理の基盤技術についてまとめる.

#通信プリミティブ
計算機同士の通信において,通信プリミティブというメッセージを送受信するライブラリ関数やシステムコール関数がある.(sendやreceive)など.

これらの関数は信頼性において優れている点と欠点が存在する.
まず,優れている点として,
・送信したメッセージが途中で失われない.
(失われた場合,再送される.)
・有限時間以内に通信相手のプロセスに届けられ,
そうでない場合,エラーメッセージを得られる.

欠点として,
途中でメッセージが失われたとしても何もしない.

といった点が挙げられる.


以下では通信プリミティブの性質について説明する.
#結合(コネクション)
データ通信において,結合をするか,しないかというのは状況によって異なる.

具体的に,結合が必要な場合は,送りたいデータをすぐに送れない場合である.この場合,事前に結合を確立する必要がある.

例:
   結合が必要->電話
         不必要->郵便

#アドレスの指定方法
次にプロセス間通信(IPC)において,アドレスの指定方法を説明する.つまり送受信するプロセスをどのように指定するかを説明する.
アドレス指定の方法として直接指定する方法と間接的に指定する方法がある.

直接では直接受信するプロセスを指定し,間接
ではプロセスではなく,メールボックスをしていする.メールボックスは複数のプロセスで共有も出来る.


#同期式,非同期式
さらなる性質としてsend(),recv()が同期式か非同期式かの区別がある.

まず同期式の場合について説明する.
send()では相手がrecv()するまで処理が停止して,recv()ではメッセージが届くまで処理がブロックする.

次に非同期式を説明する.
send()ではメッセージのバッファリングを行い,相手のrecv()をまたずに,処理を先に進める.
ここでバッファリングとはOSなどが持つメモリにメッセージをコピーすることである.

recv()ではメッセージが届いていなくても即座に処理が戻ってくる.
ここでメッセージの到着は,ポーリングや割り込み,別のプリミティブなどで調べる必要ようがある.


#マルチキャスト,ユニキャスト,ブロードキャスト

通信プリミティブの性質として,マルチキャスト通信が可能かどうかということがある.
1つのメッセージについて考えると,送信側のプロセスは1つである.

ユニキャスト
-送信側プロセス1個,受信側のプロセス1個

マルチキャスト
-送信側のプロセス1個,受信側のプロセスは複数

マルチキャストに似た者としてブロードキャストがある.

ブロードキャスト
-特定の物理的な通信媒体に接続しているプロセス全てにメッセージを送信.

ブロードキャストは全てのプロセスにメッセージを送るが,マルチキャストは受信したいと思っているプロセスにだけメッセージが送られる.

#帯域保証と遅延保障
通信プリミティブには帯域保証や遅延保障を持つものがある.

帯域保証とは毎秒どのくらいのデータを送ることが出来るかを保証することである.
例:固定電話は64kbpsの帯域が保証されている.

遅延保障とはsend()してからrecv()するまで,最長どのくらいの時間がかかるかを保証することである.言い換えると,送ったデータが最悪でも○ミリ秒以内には必ず届くと約束することである.


#データグラムとストリーム
現在,広く利用可能な通信プリミティブはデータグラム,またはストリームを転送するサービスを提供するものである.

データグラムとストリームについて説明する.

データグラムとはデータとテレグラムを結合して作られた言葉で,ひとかたまりのメッセージを意味する.
データグラムでは結合が作られず,send()の引数にはメッセージと通信相手のアドレスを与える.

一般にデータグラムは信頼性がないものを指し,
メッセージが失われても,何もしない.また,メッセージの前後が入れ替わる可能性がある.

次に,ストリームはTCPでは通信する2つのプロセスの間で結合が作られる.ストリームでの通信は
通信する2つのプロセスの間で結合が造られた,メッセージの順序が入れ替わることもなく,信頼性がある.


#整列化と非整列化

整列化とはメモリ上に散らばって保存されたいるデータを,ネットワークに流すときに都合がよいように,ひとかたまりにまとめることである.
プログラム中のデータの配列や構造体,オブジェクトなどはメモリ上,バラバラな場所にある.
しかし,ネットワークはバイト列を先頭から順番に流すだけである.
整列化を行うことで,メモリ上のデータ構造を通信できる形に変換する.

ポインタを相手に送信しても,ポインタが指すデータを送らなければ,値に干渉できない.
よって,整列化ではポインタが指す値ごと送信するが,ポインタが多段になると,整列化が複雑になってしまう.
javaではシリアライズという.

非整列化とは受け手側で元(整列化前)のデータに戻すことである.



#バイトオーダー


分散プログラムではメッセージを送信するプロセスと受信するプロセスが異なる場合がある.
具体的には別のOSだったり,別のCPUのプロセスとやりとりする可能性がある.
よって整数を送る場合でもバイトオーダに気を付ける必要がある.

0x12 34 56 78というデータを送るとする.

リトルエンディアン
・下位番地に下位バイトを置く方法
・下位数8ビット,16ビットだけが必要な場合有利

番地(低 → 高)
78 56 34 12

具体的に
int x = 0x12345678;
char c = x;     // 下位8bitを取り出したい
このような時,下位8bitを即時に取り出せる.
ビッグエンディアンだとこのようにしなければならない.
c = (x >> 24) & 0xff;

ビッグエンディアン
・下位番地に上位バイトを置く方法
・上位バイトからアクセスする必要があるとき有利
・人間の感覚に近い

番地(低 → 高)
12 24 56 78

具体的に,桁数判定などでは,先頭バイトを見て,非ゼロなら即,大きい値と判断できる.

次に異なるバイトオーダを持つコンピュータで整数を送受信する時,考えられる方法をを記す.
1つ目は,片方がもう片方に合わせて変換する方法である.
2つ目は,標準的なバイトオーダ(ネットワークバイトオーダ)を定める方法である.
送信側では,ネットワークにデータを流すときには,常に自分自身のバイトオーダをネットワークに変換する.
受信側ではネットワークバイトオーダから自分のホストバイトオーダに変換する.
現在のネットワークバイトオーダとしてビッグエンディアンが使われている.

#文字コード

バイトオーダ以外に,文字コードも送信側と受信側で異なることがある.







